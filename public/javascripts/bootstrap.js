!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t(require("@popperjs/core")) : "function" == typeof define && define.amd ? define(["@popperjs/core"], t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t(e.Popper) }(this, function (e) { "use strict"; function t(e) { if (e && e.__esModule) return e; const t = Object.create(null); if (e) for (const i in e) if ("default" !== i) { const n = Object.getOwnPropertyDescriptor(e, i); Object.defineProperty(t, i, n.get ? n : { enumerable: !0, get: () => e[i] }) } return t.default = e, Object.freeze(t) } const i = t(e), n = e => { let t = e.getAttribute("data-bs-target"); if (!t || "#" === t) { let i = e.getAttribute("href"); if (!i || !i.includes("#") && !i.startsWith(".")) return null; i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), t = i && "#" !== i ? i.trim() : null } return t }, s = e => { const t = n(e); return t && document.querySelector(t) ? t : null }, o = e => { const t = n(e); return t ? document.querySelector(t) : null }, r = e => { e.dispatchEvent(new Event("transitionend")) }, a = e => !(!e || "object" != typeof e) && (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType), l = e => a(e) ? e.jquery ? e[0] : e : "string" == typeof e && e.length > 0 ? document.querySelector(e) : null, c = (e, t, i) => { Object.keys(i).forEach(n => { const s = i[n], o = t[n], r = o && a(o) ? "element" : (e => null == e ? `${e}` : {}.toString.call(e).match(/\s([a-z]+)/i)[1].toLowerCase())(o); if (!new RegExp(s).test(r)) throw new TypeError(`${e.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`) }) }, h = e => !(!a(e) || 0 === e.getClientRects().length) && "visible" === getComputedStyle(e).getPropertyValue("visibility"), d = e => !e || e.nodeType !== Node.ELEMENT_NODE || (!!e.classList.contains("disabled") || (void 0 !== e.disabled ? e.disabled : e.hasAttribute("disabled") && "false" !== e.getAttribute("disabled"))), u = () => { }, f = e => { e.offsetHeight }, g = () => { const { jQuery: e } = window; return e && !document.body.hasAttribute("data-bs-no-jquery") ? e : null }, p = [], m = () => "rtl" === document.documentElement.dir, _ = e => { (e => { "loading" === document.readyState ? (p.length || document.addEventListener("DOMContentLoaded", () => { p.forEach(e => e()) }), p.push(e)) : e() })(() => { const t = g(); if (t) { const i = e.NAME, n = t.fn[i]; t.fn[i] = e.jQueryInterface, t.fn[i].Constructor = e, t.fn[i].noConflict = (() => (t.fn[i] = n, e.jQueryInterface)) } }) }, b = e => { "function" == typeof e && e() }, v = (e, t, i = !0) => { if (!i) return void b(e); const n = (e => { if (!e) return 0; let { transitionDuration: t, transitionDelay: i } = window.getComputedStyle(e); const n = Number.parseFloat(t), s = Number.parseFloat(i); return n || s ? (t = t.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(t) + Number.parseFloat(i))) : 0 })(t) + 5; let s = !1; const o = ({ target: i }) => { i === t && (s = !0, t.removeEventListener("transitionend", o), b(e)) }; t.addEventListener("transitionend", o), setTimeout(() => { s || r(t) }, n) }, y = (e, t, i, n) => { let s = e.indexOf(t); if (-1 === s) return e[!i && n ? e.length - 1 : 0]; const o = e.length; return s += i ? 1 : -1, n && (s = (s + o) % o), e[Math.max(0, Math.min(s, o - 1))] }, w = /[^.]*(?=\..*)\.|.*/, E = /\..*/, A = /::\d+$/, k = {}; let C = 1; const T = { mouseenter: "mouseover", mouseleave: "mouseout" }, I = /^(mouseenter|mouseleave)/i, O = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function S(e, t) { return t && `${t}::${C++}` || e.uidEvent || C++ } function D(e) { const t = S(e); return e.uidEvent = t, k[t] = k[t] || {}, k[t] } function N(e, t, i = null) { const n = Object.keys(e); for (let s = 0, o = n.length; s < o; s++) { const o = e[n[s]]; if (o.originalHandler === t && o.delegationSelector === i) return o } return null } function L(e, t, i) { const n = "string" == typeof t, s = n ? i : t; let o = j(e); return O.has(o) || (o = e), [n, s, o] } function x(e, t, i, n, s) { if ("string" != typeof t || !e) return; if (i || (i = n, n = null), I.test(t)) { const e = e => (function (t) { if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return e.call(this, t) }); n ? n = e(n) : i = e(i) } const [o, r, a] = L(t, i, n), l = D(e), c = l[a] || (l[a] = {}), h = N(c, r, o ? i : null); if (h) return void (h.oneOff = h.oneOff && s); const d = S(r, t.replace(w, "")), u = o ? function (e, t, i) { return function n(s) { const o = e.querySelectorAll(t); for (let { target: r } = s; r && r !== this; r = r.parentNode)for (let a = o.length; a--;)if (o[a] === r) return s.delegateTarget = r, n.oneOff && P.off(e, s.type, t, i), i.apply(r, [s]); return null } }(e, i, n) : function (e, t) { return function i(n) { return n.delegateTarget = e, i.oneOff && P.off(e, n.type, t), t.apply(e, [n]) } }(e, i); u.delegationSelector = o ? i : null, u.originalHandler = r, u.oneOff = s, u.uidEvent = d, c[d] = u, e.addEventListener(a, u, o) } function $(e, t, i, n, s) { const o = N(t[i], n, s); o && (e.removeEventListener(i, o, Boolean(s)), delete t[i][o.uidEvent]) } function j(e) { return e = e.replace(E, ""), T[e] || e } const P = { on(e, t, i, n) { x(e, t, i, n, !1) }, one(e, t, i, n) { x(e, t, i, n, !0) }, off(e, t, i, n) { if ("string" != typeof t || !e) return; const [s, o, r] = L(t, i, n), a = r !== t, l = D(e), c = t.startsWith("."); if (void 0 !== o) { if (!l || !l[r]) return; return void $(e, l, r, o, s ? i : null) } c && Object.keys(l).forEach(i => { !function (e, t, i, n) { const s = t[i] || {}; Object.keys(s).forEach(o => { if (o.includes(n)) { const n = s[o]; $(e, t, i, n.originalHandler, n.delegationSelector) } }) }(e, l, i, t.slice(1)) }); const h = l[r] || {}; Object.keys(h).forEach(i => { const n = i.replace(A, ""); if (!a || t.includes(n)) { const t = h[i]; $(e, l, r, t.originalHandler, t.delegationSelector) } }) }, trigger(e, t, i) { if ("string" != typeof t || !e) return null; const n = g(), s = j(t), o = t !== s, r = O.has(s); let a, l = !0, c = !0, h = !1, d = null; return o && n && (a = n.Event(t, i), n(e).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), h = a.isDefaultPrevented()), r ? (d = document.createEvent("HTMLEvents")).initEvent(s, l, !0) : d = new CustomEvent(t, { bubbles: l, cancelable: !0 }), void 0 !== i && Object.keys(i).forEach(e => { Object.defineProperty(d, e, { get: () => i[e] }) }), h && d.preventDefault(), c && e.dispatchEvent(d), d.defaultPrevented && void 0 !== a && a.preventDefault(), d } }, M = new Map, q = { set(e, t, i) { M.has(e) || M.set(e, new Map); const n = M.get(e); n.has(t) || 0 === n.size ? n.set(t, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`) }, get: (e, t) => M.has(e) && M.get(e).get(t) || null, remove(e, t) { if (!M.has(e)) return; const i = M.get(e); i.delete(t), 0 === i.size && M.delete(e) } }, R = "5.1.3"; class B { constructor(e) { (e = l(e)) && (this._element = e, q.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { q.remove(this._element, this.constructor.DATA_KEY), P.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(e => { this[e] = null }) } _queueCallback(e, t, i = !0) { v(e, t, i) } static getInstance(e) { return q.get(l(e), this.DATA_KEY) } static getOrCreateInstance(e, t = {}) { return this.getInstance(e) || new this(e, "object" == typeof t ? t : null) } static get VERSION() { return R } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } } const W = (e, t = "hide") => { const i = `click.dismiss${e.EVENT_KEY}`, n = e.NAME; P.on(document, i, `[data-bs-dismiss="${n}"]`, function (i) { if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), d(this)) return; const s = o(this) || this.closest(`.${n}`); e.getOrCreateInstance(s)[t]() }) }, X = "alert", H = "close.bs.alert", K = "closed.bs.alert", F = "fade", V = "show"; class z extends B { static get NAME() { return X } close() { if (P.trigger(this._element, H).defaultPrevented) return; this._element.classList.remove(V); const e = this._element.classList.contains(F); this._queueCallback(() => this._destroyElement(), this._element, e) } _destroyElement() { this._element.remove(), P.trigger(this._element, K), this.dispose() } static jQueryInterface(e) { return this.each(function () { const t = z.getOrCreateInstance(this); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`); t[e](this) } }) } } W(z, "close"), _(z); const Y = "button", Q = "active"; class U extends B { static get NAME() { return Y } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle(Q)) } static jQueryInterface(e) { return this.each(function () { const t = U.getOrCreateInstance(this); "toggle" === e && t[e]() }) } } function Z(e) { return "true" === e || "false" !== e && (e === Number(e).toString() ? Number(e) : "" === e || "null" === e ? null : e) } function G(e) { return e.replace(/[A-Z]/g, e => `-${e.toLowerCase()}`) } P.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', e => { e.preventDefault(); const t = e.target.closest('[data-bs-toggle="button"]'); U.getOrCreateInstance(t).toggle() }), _(U); const J = { setDataAttribute(e, t, i) { e.setAttribute(`data-bs-${G(t)}`, i) }, removeDataAttribute(e, t) { e.removeAttribute(`data-bs-${G(t)}`) }, getDataAttributes(e) { if (!e) return {}; const t = {}; return Object.keys(e.dataset).filter(e => e.startsWith("bs")).forEach(i => { let n = i.replace(/^bs/, ""); n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = Z(e.dataset[i]) }), t }, getDataAttribute: (e, t) => Z(e.getAttribute(`data-bs-${G(t)}`)), offset(e) { const t = e.getBoundingClientRect(); return { top: t.top + window.pageYOffset, left: t.left + window.pageXOffset } }, position: e => ({ top: e.offsetTop, left: e.offsetLeft }) }, ee = { find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)), findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e), children: (e, t) => [].concat(...e.children).filter(e => e.matches(t)), parents(e, t) { const i = []; let n = e.parentNode; for (; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType;)n.matches(t) && i.push(n), n = n.parentNode; return i }, prev(e, t) { let i = e.previousElementSibling; for (; i;) { if (i.matches(t)) return [i]; i = i.previousElementSibling } return [] }, next(e, t) { let i = e.nextElementSibling; for (; i;) { if (i.matches(t)) return [i]; i = i.nextElementSibling } return [] }, focusableChildren(e) { const t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(e => `${e}:not([tabindex^="-"])`).join(", "); return this.find(t, e).filter(e => !d(e) && h(e)) } }, te = "carousel", ie = 500, ne = 40, se = { interval: 5e3, keyboard: !0, slide: !1, pause: "hover", wrap: !0, touch: !0 }, oe = { interval: "(number|boolean)", keyboard: "boolean", slide: "(boolean|string)", pause: "(string|boolean)", wrap: "boolean", touch: "boolean" }, re = "next", ae = "prev", le = "left", ce = "right", he = { ArrowLeft: ce, ArrowRight: le }, de = "slide.bs.carousel", ue = "slid.bs.carousel", fe = "keydown.bs.carousel", ge = "mouseenter.bs.carousel", pe = "mouseleave.bs.carousel", me = "touchstart.bs.carousel", _e = "touchmove.bs.carousel", be = "touchend.bs.carousel", ve = "pointerdown.bs.carousel", ye = "pointerup.bs.carousel", we = "dragstart.bs.carousel", Ee = "carousel", Ae = "active", ke = "slide", Ce = "carousel-item-end", Te = "carousel-item-start", Ie = "carousel-item-next", Oe = "carousel-item-prev", Se = "pointer-event", De = ".active", Ne = ".active.carousel-item", Le = ".carousel-item", xe = ".carousel-item img", $e = ".carousel-item-next, .carousel-item-prev", je = ".carousel-indicators", Pe = "[data-bs-target]", Me = "touch", qe = "pen"; class Re extends B { constructor(e, t) { super(e), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(t), this._indicatorsElement = ee.findOne(je, this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners() } static get Default() { return se } static get NAME() { return te } next() { this._slide(re) } nextWhenVisible() { !document.hidden && h(this._element) && this.next() } prev() { this._slide(ae) } pause(e) { e || (this._isPaused = !0), ee.findOne($e, this._element) && (r(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null } cycle(e) { e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)) } to(e) { this._activeElement = ee.findOne(Ne, this._element); const t = this._getItemIndex(this._activeElement); if (e > this._items.length - 1 || e < 0) return; if (this._isSliding) return void P.one(this._element, ue, () => this.to(e)); if (t === e) return this.pause(), void this.cycle(); const i = e > t ? re : ae; this._slide(i, this._items[e]) } _getConfig(e) { return e = { ...se, ...J.getDataAttributes(this._element), ..."object" == typeof e ? e : {} }, c(te, e, oe), e } _handleSwipe() { const e = Math.abs(this.touchDeltaX); if (e <= ne) return; const t = e / this.touchDeltaX; this.touchDeltaX = 0, t && this._slide(t > 0 ? ce : le) } _addEventListeners() { this._config.keyboard && P.on(this._element, fe, e => this._keydown(e)), "hover" === this._config.pause && (P.on(this._element, ge, e => this.pause(e)), P.on(this._element, pe, e => this.cycle(e))), this._config.touch && this._touchSupported && this._addTouchEventListeners() } _addTouchEventListeners() { const e = e => this._pointerEvent && (e.pointerType === qe || e.pointerType === Me), t = t => { e(t) ? this.touchStartX = t.clientX : this._pointerEvent || (this.touchStartX = t.touches[0].clientX) }, i = e => { this.touchDeltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this.touchStartX }, n = t => { e(t) && (this.touchDeltaX = t.clientX - this.touchStartX), this._handleSwipe(), "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(e => this.cycle(e), ie + this._config.interval)) }; ee.find(xe, this._element).forEach(e => { P.on(e, we, e => e.preventDefault()) }), this._pointerEvent ? (P.on(this._element, ve, e => t(e)), P.on(this._element, ye, e => n(e)), this._element.classList.add(Se)) : (P.on(this._element, me, e => t(e)), P.on(this._element, _e, e => i(e)), P.on(this._element, be, e => n(e))) } _keydown(e) { if (/input|textarea/i.test(e.target.tagName)) return; const t = he[e.key]; t && (e.preventDefault(), this._slide(t)) } _getItemIndex(e) { return this._items = e && e.parentNode ? ee.find(Le, e.parentNode) : [], this._items.indexOf(e) } _getItemByOrder(e, t) { const i = e === re; return y(this._items, t, i, this._config.wrap) } _triggerSlideEvent(e, t) { const i = this._getItemIndex(e), n = this._getItemIndex(ee.findOne(Ne, this._element)); return P.trigger(this._element, de, { relatedTarget: e, direction: t, from: n, to: i }) } _setActiveIndicatorElement(e) { if (this._indicatorsElement) { const t = ee.findOne(De, this._indicatorsElement); t.classList.remove(Ae), t.removeAttribute("aria-current"); const i = ee.find(Pe, this._indicatorsElement); for (let t = 0; t < i.length; t++)if (Number.parseInt(i[t].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(e)) { i[t].classList.add(Ae), i[t].setAttribute("aria-current", "true"); break } } } _updateInterval() { const e = this._activeElement || ee.findOne(Ne, this._element); if (!e) return; const t = Number.parseInt(e.getAttribute("data-bs-interval"), 10); t ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = t) : this._config.interval = this._config.defaultInterval || this._config.interval } _slide(e, t) { const i = this._directionToOrder(e), n = ee.findOne(Ne, this._element), s = this._getItemIndex(n), o = t || this._getItemByOrder(i, n), r = this._getItemIndex(o), a = Boolean(this._interval), l = i === re, c = l ? Te : Ce, h = l ? Ie : Oe, d = this._orderToDirection(i); if (o && o.classList.contains(Ae)) return void (this._isSliding = !1); if (this._isSliding) return; if (this._triggerSlideEvent(o, d).defaultPrevented) return; if (!n || !o) return; this._isSliding = !0, a && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o; const u = () => { P.trigger(this._element, ue, { relatedTarget: o, direction: d, from: s, to: r }) }; if (this._element.classList.contains(ke)) { o.classList.add(h), f(o), n.classList.add(c), o.classList.add(c); const e = () => { o.classList.remove(c, h), o.classList.add(Ae), n.classList.remove(Ae, h, c), this._isSliding = !1, setTimeout(u, 0) }; this._queueCallback(e, n, !0) } else n.classList.remove(Ae), o.classList.add(Ae), this._isSliding = !1, u(); a && this.cycle() } _directionToOrder(e) { return [ce, le].includes(e) ? m() ? e === le ? ae : re : e === le ? re : ae : e } _orderToDirection(e) { return [re, ae].includes(e) ? m() ? e === ae ? le : ce : e === ae ? ce : le : e } static carouselInterface(e, t) { const i = Re.getOrCreateInstance(e, t); let { _config: n } = i; "object" == typeof t && (n = { ...n, ...t }); const s = "string" == typeof t ? t : n.slide; if ("number" == typeof t) i.to(t); else if ("string" == typeof s) { if (void 0 === i[s]) throw new TypeError(`No method named "${s}"`); i[s]() } else n.interval && n.ride && (i.pause(), i.cycle()) } static jQueryInterface(e) { return this.each(function () { Re.carouselInterface(this, e) }) } static dataApiClickHandler(e) { const t = o(this); if (!t || !t.classList.contains(Ee)) return; const i = { ...J.getDataAttributes(t), ...J.getDataAttributes(this) }, n = this.getAttribute("data-bs-slide-to"); n && (i.interval = !1), Re.carouselInterface(t, i), n && Re.getInstance(t).to(n), e.preventDefault() } } P.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Re.dataApiClickHandler), P.on(window, "load.bs.carousel.data-api", () => { const e = ee.find('[data-bs-ride="carousel"]'); for (let t = 0, i = e.length; t < i; t++)Re.carouselInterface(e[t], Re.getInstance(e[t])) }), _(Re); const Be = "collapse", We = "bs.collapse", Xe = `.${We}`, He = { toggle: !0, parent: null }, Ke = { toggle: "boolean", parent: "(null|element)" }, Fe = `show${Xe}`, Ve = `shown${Xe}`, ze = `hide${Xe}`, Ye = `hidden${Xe}`, Qe = `click${Xe}.data-api`, Ue = "show", Ze = "collapse", Ge = "collapsing", Je = "collapsed", et = `:scope .${Ze} .${Ze}`, tt = "collapse-horizontal", it = "width", nt = "height", st = ".collapse.show, .collapse.collapsing", ot = '[data-bs-toggle="collapse"]'; class rt extends B { constructor(e, t) { super(e), this._isTransitioning = !1, this._config = this._getConfig(t), this._triggerArray = []; const i = ee.find(ot); for (let e = 0, t = i.length; e < t; e++) { const t = i[e], n = s(t), o = ee.find(n).filter(e => e === this._element); null !== n && o.length && (this._selector = n, this._triggerArray.push(t)) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return He } static get NAME() { return Be } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let e, t = []; if (this._config.parent) { const e = ee.find(et, this._config.parent); t = ee.find(st, this._config.parent).filter(t => !e.includes(t)) } const i = ee.findOne(this._selector); if (t.length) { const n = t.find(e => i !== e); if ((e = n ? rt.getInstance(n) : null) && e._isTransitioning) return } if (P.trigger(this._element, Fe).defaultPrevented) return; t.forEach(t => { i !== t && rt.getOrCreateInstance(t, { toggle: !1 }).hide(), e || q.set(t, We, null) }); const n = this._getDimension(); this._element.classList.remove(Ze), this._element.classList.add(Ge), this._element.style[n] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const s = `scroll${n[0].toUpperCase() + n.slice(1)}`; this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove(Ge), this._element.classList.add(Ze, Ue), this._element.style[n] = "", P.trigger(this._element, Ve) }, this._element, !0), this._element.style[n] = `${this._element[s]}px` } hide() { if (this._isTransitioning || !this._isShown()) return; if (P.trigger(this._element, ze).defaultPrevented) return; const e = this._getDimension(); this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, f(this._element), this._element.classList.add(Ge), this._element.classList.remove(Ze, Ue); const t = this._triggerArray.length; for (let e = 0; e < t; e++) { const t = this._triggerArray[e], i = o(t); i && !this._isShown(i) && this._addAriaAndCollapsedClass([t], !1) } this._isTransitioning = !0; this._element.style[e] = "", this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove(Ge), this._element.classList.add(Ze), P.trigger(this._element, Ye) }, this._element, !0) } _isShown(e = this._element) { return e.classList.contains(Ue) } _getConfig(e) { return (e = { ...He, ...J.getDataAttributes(this._element), ...e }).toggle = Boolean(e.toggle), e.parent = l(e.parent), c(Be, e, Ke), e } _getDimension() { return this._element.classList.contains(tt) ? it : nt } _initializeChildren() { if (!this._config.parent) return; const e = ee.find(et, this._config.parent); ee.find(ot, this._config.parent).filter(t => !e.includes(t)).forEach(e => { const t = o(e); t && this._addAriaAndCollapsedClass([e], this._isShown(t)) }) } _addAriaAndCollapsedClass(e, t) { e.length && e.forEach(e => { t ? e.classList.remove(Je) : e.classList.add(Je), e.setAttribute("aria-expanded", t) }) } static jQueryInterface(e) { return this.each(function () { const t = {}; "string" == typeof e && /show|hide/.test(e) && (t.toggle = !1); const i = rt.getOrCreateInstance(this, t); if ("string" == typeof e) { if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`); i[e]() } }) } } P.on(document, Qe, ot, function (e) { ("A" === e.target.tagName || e.delegateTarget && "A" === e.delegateTarget.tagName) && e.preventDefault(); const t = s(this); ee.find(t).forEach(e => { rt.getOrCreateInstance(e, { toggle: !1 }).toggle() }) }), _(rt); const at = "dropdown", lt = "Escape", ct = "Space", ht = "Tab", dt = "ArrowUp", ut = "ArrowDown", ft = 2, gt = new RegExp(`${dt}|${ut}|${lt}`), pt = "hide.bs.dropdown", mt = "hidden.bs.dropdown", _t = "show.bs.dropdown", bt = "shown.bs.dropdown", vt = "show", yt = "dropup", wt = "dropend", Et = "dropstart", At = "navbar", kt = '[data-bs-toggle="dropdown"]', Ct = ".dropdown-menu", Tt = ".navbar-nav", It = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", Ot = m() ? "top-end" : "top-start", St = m() ? "top-start" : "top-end", Dt = m() ? "bottom-end" : "bottom-start", Nt = m() ? "bottom-start" : "bottom-end", Lt = m() ? "left-start" : "right-start", xt = m() ? "right-start" : "left-start", $t = { offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, autoClose: !0 }, jt = { offset: "(array|string|function)", boundary: "(string|element)", reference: "(string|element|object)", display: "string", popperConfig: "(null|object|function)", autoClose: "(boolean|string)" }; class Pt extends B { constructor(e, t) { super(e), this._popper = null, this._config = this._getConfig(t), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar() } static get Default() { return $t } static get DefaultType() { return jt } static get NAME() { return at } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (d(this._element) || this._isShown(this._menu)) return; const e = { relatedTarget: this._element }; if (P.trigger(this._element, _t, e).defaultPrevented) return; const t = Pt.getParentFromElement(this._element); this._inNavbar ? J.setDataAttribute(this._menu, "popper", "none") : this._createPopper(t), "ontouchstart" in document.documentElement && !t.closest(Tt) && [].concat(...document.body.children).forEach(e => P.on(e, "mouseover", u)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(vt), this._element.classList.add(vt), P.trigger(this._element, bt, e) } hide() { if (d(this._element) || !this._isShown(this._menu)) return; const e = { relatedTarget: this._element }; this._completeHide(e) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(e) { P.trigger(this._element, pt, e).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(e => P.off(e, "mouseover", u)), this._popper && this._popper.destroy(), this._menu.classList.remove(vt), this._element.classList.remove(vt), this._element.setAttribute("aria-expanded", "false"), J.removeDataAttribute(this._menu, "popper"), P.trigger(this._element, mt, e)) } _getConfig(e) { if (e = { ...this.constructor.Default, ...J.getDataAttributes(this._element), ...e }, c(at, e, this.constructor.DefaultType), "object" == typeof e.reference && !a(e.reference) && "function" != typeof e.reference.getBoundingClientRect) throw new TypeError(`${at.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return e } _createPopper(e) { if (void 0 === i) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let t = this._element; "parent" === this._config.reference ? t = e : a(this._config.reference) ? t = l(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference); const n = this._getPopperConfig(), s = n.modifiers.find(e => "applyStyles" === e.name && !1 === e.enabled); this._popper = i.createPopper(t, this._menu, n), s && J.setDataAttribute(this._menu, "popper", "static") } _isShown(e = this._element) { return e.classList.contains(vt) } _getMenuElement() { return ee.next(this._element, Ct)[0] } _getPlacement() { const e = this._element.parentNode; if (e.classList.contains(wt)) return Lt; if (e.classList.contains(Et)) return xt; const t = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim(); return e.classList.contains(yt) ? t ? St : Ot : t ? Nt : Dt } _detectNavbar() { return null !== this._element.closest(`.${At}`) } _getOffset() { const { offset: e } = this._config; return "string" == typeof e ? e.split(",").map(e => Number.parseInt(e, 10)) : "function" == typeof e ? t => e(t, this._element) : e } _getPopperConfig() { const e = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return "static" === this._config.display && (e.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...e, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig } } _selectMenuItem({ key: e, target: t }) { const i = ee.find(It, this._menu).filter(h); i.length && y(i, t, e === ut, !i.includes(t)).focus() } static jQueryInterface(e) { return this.each(function () { const t = Pt.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } }) } static clearMenus(e) { if (e && (e.button === ft || "keyup" === e.type && e.key !== ht)) return; const t = ee.find(kt); for (let i = 0, n = t.length; i < n; i++) { const n = Pt.getInstance(t[i]); if (!n || !1 === n._config.autoClose) continue; if (!n._isShown()) continue; const s = { relatedTarget: n._element }; if (e) { const t = e.composedPath(), i = t.includes(n._menu); if (t.includes(n._element) || "inside" === n._config.autoClose && !i || "outside" === n._config.autoClose && i) continue; if (n._menu.contains(e.target) && ("keyup" === e.type && e.key === ht || /input|select|option|textarea|form/i.test(e.target.tagName))) continue; "click" === e.type && (s.clickEvent = e) } n._completeHide(s) } } static getParentFromElement(e) { return o(e) || e.parentNode } static dataApiKeydownHandler(e) { if (/input|textarea/i.test(e.target.tagName) ? e.key === ct || e.key !== lt && (e.key !== ut && e.key !== dt || e.target.closest(Ct)) : !gt.test(e.key)) return; const t = this.classList.contains(vt); if (!t && e.key === lt) return; if (e.preventDefault(), e.stopPropagation(), d(this)) return; const i = this.matches(kt) ? this : ee.prev(this, kt)[0], n = Pt.getOrCreateInstance(i); if (e.key !== lt) return e.key === dt || e.key === ut ? (t || n.show(), void n._selectMenuItem(e)) : void (t && e.key !== ct || Pt.clearMenus()); n.hide() } } P.on(document, "keydown.bs.dropdown.data-api", kt, Pt.dataApiKeydownHandler), P.on(document, "keydown.bs.dropdown.data-api", Ct, Pt.dataApiKeydownHandler), P.on(document, "click.bs.dropdown.data-api", Pt.clearMenus), P.on(document, "keyup.bs.dropdown.data-api", Pt.clearMenus), P.on(document, "click.bs.dropdown.data-api", kt, function (e) { e.preventDefault(), Pt.getOrCreateInstance(this).toggle() }), _(Pt); const Mt = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", qt = ".sticky-top"; class Rt { constructor() { this._element = document.body } getWidth() { const e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e) } hide() { const e = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", t => t + e), this._setElementAttributes(Mt, "paddingRight", t => t + e), this._setElementAttributes(qt, "marginRight", t => t - e) } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(e, t, i) { const n = this.getWidth(); this._applyManipulationCallback(e, e => { if (e !== this._element && window.innerWidth > e.clientWidth + n) return; this._saveInitialAttribute(e, t); const s = window.getComputedStyle(e)[t]; e.style[t] = `${i(Number.parseFloat(s))}px` }) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(Mt, "paddingRight"), this._resetElementAttributes(qt, "marginRight") } _saveInitialAttribute(e, t) { const i = e.style[t]; i && J.setDataAttribute(e, t, i) } _resetElementAttributes(e, t) { this._applyManipulationCallback(e, e => { const i = J.getDataAttribute(e, t); void 0 === i ? e.style.removeProperty(t) : (J.removeDataAttribute(e, t), e.style[t] = i) }) } _applyManipulationCallback(e, t) { a(e) ? t(e) : ee.find(e, this._element).forEach(t) } isOverflowing() { return this.getWidth() > 0 } } const Bt = { className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null }, Wt = { className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" }, Xt = "backdrop", Ht = "fade", Kt = "show", Ft = `mousedown.bs.${Xt}`; class Vt { constructor(e) { this._config = this._getConfig(e), this._isAppended = !1, this._element = null } show(e) { this._config.isVisible ? (this._append(), this._config.isAnimated && f(this._getElement()), this._getElement().classList.add(Kt), this._emulateAnimation(() => { b(e) })) : b(e) } hide(e) { this._config.isVisible ? (this._getElement().classList.remove(Kt), this._emulateAnimation(() => { this.dispose(), b(e) })) : b(e) } _getElement() { if (!this._element) { const e = document.createElement("div"); e.className = this._config.className, this._config.isAnimated && e.classList.add(Ht), this._element = e } return this._element } _getConfig(e) { return (e = { ...Bt, ..."object" == typeof e ? e : {} }).rootElement = l(e.rootElement), c(Xt, e, Wt), e } _append() { this._isAppended || (this._config.rootElement.append(this._getElement()), P.on(this._getElement(), Ft, () => { b(this._config.clickCallback) }), this._isAppended = !0) } dispose() { this._isAppended && (P.off(this._element, Ft), this._element.remove(), this._isAppended = !1) } _emulateAnimation(e) { v(e, this._getElement(), this._config.isAnimated) } } const zt = { trapElement: null, autofocus: !0 }, Yt = { trapElement: "element", autofocus: "boolean" }, Qt = "focustrap", Ut = ".bs.focustrap", Zt = `focusin${Ut}`, Gt = `keydown.tab${Ut}`, Jt = "Tab", ei = "forward", ti = "backward"; class ii { constructor(e) { this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null } activate() { const { trapElement: e, autofocus: t } = this._config; this._isActive || (t && e.focus(), P.off(document, Ut), P.on(document, Zt, e => this._handleFocusin(e)), P.on(document, Gt, e => this._handleKeydown(e)), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, P.off(document, Ut)) } _handleFocusin(e) { const { target: t } = e, { trapElement: i } = this._config; if (t === document || t === i || i.contains(t)) return; const n = ee.focusableChildren(i); 0 === n.length ? i.focus() : this._lastTabNavDirection === ti ? n[n.length - 1].focus() : n[0].focus() } _handleKeydown(e) { e.key === Jt && (this._lastTabNavDirection = e.shiftKey ? ti : ei) } _getConfig(e) { return e = { ...zt, ..."object" == typeof e ? e : {} }, c(Qt, e, Yt), e } } const ni = "offcanvas", si = "Escape", oi = { backdrop: !0, keyboard: !0, scroll: !1 }, ri = { backdrop: "boolean", keyboard: "boolean", scroll: "boolean" }, ai = "show", li = "offcanvas-backdrop", ci = "show.bs.offcanvas", hi = "shown.bs.offcanvas", di = "hide.bs.offcanvas", ui = "hidden.bs.offcanvas", fi = "keydown.dismiss.bs.offcanvas"; class gi extends B { constructor(e, t) { super(e), this._config = this._getConfig(t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get NAME() { return ni } static get Default() { return oi } toggle(e) { return this._isShown ? this.hide() : this.show(e) } show(e) { if (this._isShown) return; if (P.trigger(this._element, ci, { relatedTarget: e }).defaultPrevented) return; this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || (new Rt).hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(ai); this._queueCallback(() => { this._config.scroll || this._focustrap.activate(), P.trigger(this._element, hi, { relatedTarget: e }) }, this._element, !0) } hide() { if (!this._isShown) return; if (P.trigger(this._element, di).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove(ai), this._backdrop.hide(); this._queueCallback(() => { this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || (new Rt).reset(), P.trigger(this._element, ui) }, this._element, !0) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _getConfig(e) { return e = { ...oi, ...J.getDataAttributes(this._element), ..."object" == typeof e ? e : {} }, c(ni, e, ri), e } _initializeBackDrop() { return new Vt({ className: li, isVisible: this._config.backdrop, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: () => this.hide() }) } _initializeFocusTrap() { return new ii({ trapElement: this._element }) } _addEventListeners() { P.on(this._element, fi, e => { this._config.keyboard && e.key === si && this.hide() }) } static jQueryInterface(e) { return this.each(function () { const t = gi.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`); t[e](this) } }) } } P.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', function (e) { const t = o(this); if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), d(this)) return; P.one(t, ui, () => { h(this) && this.focus() }); const i = ee.findOne(".offcanvas.show"); i && i !== t && gi.getInstance(i).hide(), gi.getOrCreateInstance(t).toggle(this) }), P.on(window, "load.bs.offcanvas.data-api", () => ee.find(".offcanvas.show").forEach(e => gi.getOrCreateInstance(e).show())), W(gi), _(gi); new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]); return { Alert: z, Button: U, Carousel: Re, Collapse: rt, Dropdown: Pt, Offcanvas: gi } });